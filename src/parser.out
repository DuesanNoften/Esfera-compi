Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> statement
Rule 1     statement -> PROC NAME ( expression )
Rule 2     statement -> COMMENT
Rule 3     statement -> PRINTLINE
Rule 4     statement -> expression
Rule 5     statement -> PRINT PRINTLINE
Rule 6     expression -> expression + expression
Rule 7     expression -> expression - expression
Rule 8     expression -> expression * expression
Rule 9     expression -> expression / expression
Rule 10    expression -> - expression
Rule 11    expression -> ( expression )
Rule 12    expression -> INTEGER
Rule 13    expression -> BOOL
Rule 14    expression -> NAME
Rule 15    expression -> DEF ( NAME , expression )
Rule 16    expression -> NAME ( expression )
Rule 17    expression -> ALTER ( NAME , expression )
Rule 18    expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

Terminals, with rules where they appear

(                    : 1 11 15 16 17
)                    : 1 11 15 16 17
*                    : 8
+                    : 6
,                    : 15 17
-                    : 7 10
/                    : 9
ALTER                : 17
BOOL                 : 13
BREAK                : 18
COMMENT              : 2
DEF                  : 15
INTEGER              : 12
LPAREN               : 18
NAME                 : 1 14 15 16 17
PRINT                : 5
PRINTLINE            : 3 5
PROC                 : 1
REPEAT               : 18
RPAREN               : 18
SEMICOLON            : 18 18 18
error                : 

Nonterminals, with rules where they appear

expression           : 1 4 6 6 7 7 8 8 9 9 10 11 15 16 17 18
statement            : 0

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . PROC NAME ( expression )
    (2) statement -> . COMMENT
    (3) statement -> . PRINTLINE
    (4) statement -> . expression
    (5) statement -> . PRINT PRINTLINE
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    PROC            shift and go to state 2
    COMMENT         shift and go to state 6
    PRINTLINE       shift and go to state 7
    PRINT           shift and go to state 8
    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    statement                      shift and go to state 1
    expression                     shift and go to state 5

state 1

    (0) S' -> statement .



state 2

    (1) statement -> PROC . NAME ( expression )

    NAME            shift and go to state 15


state 3

    (14) expression -> NAME .
    (16) expression -> NAME . ( expression )

    +               reduce using rule 14 (expression -> NAME .)
    -               reduce using rule 14 (expression -> NAME .)
    *               reduce using rule 14 (expression -> NAME .)
    /               reduce using rule 14 (expression -> NAME .)
    $end            reduce using rule 14 (expression -> NAME .)
    )               reduce using rule 14 (expression -> NAME .)
    SEMICOLON       reduce using rule 14 (expression -> NAME .)
    (               shift and go to state 16


state 4

    (11) expression -> ( . expression )
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 17

state 5

    (4) statement -> expression .
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    $end            reduce using rule 4 (statement -> expression .)
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 6

    (2) statement -> COMMENT .

    $end            reduce using rule 2 (statement -> COMMENT .)


state 7

    (3) statement -> PRINTLINE .

    $end            reduce using rule 3 (statement -> PRINTLINE .)


state 8

    (5) statement -> PRINT . PRINTLINE

    PRINTLINE       shift and go to state 22


state 9

    (10) expression -> - . expression
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 23

state 10

    (12) expression -> INTEGER .

    +               reduce using rule 12 (expression -> INTEGER .)
    -               reduce using rule 12 (expression -> INTEGER .)
    *               reduce using rule 12 (expression -> INTEGER .)
    /               reduce using rule 12 (expression -> INTEGER .)
    $end            reduce using rule 12 (expression -> INTEGER .)
    )               reduce using rule 12 (expression -> INTEGER .)
    SEMICOLON       reduce using rule 12 (expression -> INTEGER .)


state 11

    (13) expression -> BOOL .

    +               reduce using rule 13 (expression -> BOOL .)
    -               reduce using rule 13 (expression -> BOOL .)
    *               reduce using rule 13 (expression -> BOOL .)
    /               reduce using rule 13 (expression -> BOOL .)
    $end            reduce using rule 13 (expression -> BOOL .)
    )               reduce using rule 13 (expression -> BOOL .)
    SEMICOLON       reduce using rule 13 (expression -> BOOL .)


state 12

    (15) expression -> DEF . ( NAME , expression )

    (               shift and go to state 24


state 13

    (17) expression -> ALTER . ( NAME , expression )

    (               shift and go to state 25


state 14

    (18) expression -> REPEAT . LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    LPAREN          shift and go to state 26


state 15

    (1) statement -> PROC NAME . ( expression )

    (               shift and go to state 27


state 16

    (16) expression -> NAME ( . expression )
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 28

state 17

    (11) expression -> ( expression . )
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    )               shift and go to state 29
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 18

    (6) expression -> expression + . expression
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 30

state 19

    (7) expression -> expression - . expression
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 31

state 20

    (8) expression -> expression * . expression
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 32

state 21

    (9) expression -> expression / . expression
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 33

state 22

    (5) statement -> PRINT PRINTLINE .

    $end            reduce using rule 5 (statement -> PRINT PRINTLINE .)


state 23

    (10) expression -> - expression .
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    +               reduce using rule 10 (expression -> - expression .)
    -               reduce using rule 10 (expression -> - expression .)
    *               reduce using rule 10 (expression -> - expression .)
    /               reduce using rule 10 (expression -> - expression .)
    $end            reduce using rule 10 (expression -> - expression .)
    )               reduce using rule 10 (expression -> - expression .)
    SEMICOLON       reduce using rule 10 (expression -> - expression .)

  ! +               [ shift and go to state 18 ]
  ! -               [ shift and go to state 19 ]
  ! *               [ shift and go to state 20 ]
  ! /               [ shift and go to state 21 ]


state 24

    (15) expression -> DEF ( . NAME , expression )

    NAME            shift and go to state 34


state 25

    (17) expression -> ALTER ( . NAME , expression )

    NAME            shift and go to state 35


state 26

    (18) expression -> REPEAT LPAREN . expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 36

state 27

    (1) statement -> PROC NAME ( . expression )
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 37

state 28

    (16) expression -> NAME ( expression . )
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    )               shift and go to state 38
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 29

    (11) expression -> ( expression ) .

    +               reduce using rule 11 (expression -> ( expression ) .)
    -               reduce using rule 11 (expression -> ( expression ) .)
    *               reduce using rule 11 (expression -> ( expression ) .)
    /               reduce using rule 11 (expression -> ( expression ) .)
    $end            reduce using rule 11 (expression -> ( expression ) .)
    )               reduce using rule 11 (expression -> ( expression ) .)
    SEMICOLON       reduce using rule 11 (expression -> ( expression ) .)


state 30

    (6) expression -> expression + expression .
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    +               reduce using rule 6 (expression -> expression + expression .)
    -               reduce using rule 6 (expression -> expression + expression .)
    $end            reduce using rule 6 (expression -> expression + expression .)
    )               reduce using rule 6 (expression -> expression + expression .)
    SEMICOLON       reduce using rule 6 (expression -> expression + expression .)
    *               shift and go to state 20
    /               shift and go to state 21

  ! *               [ reduce using rule 6 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 6 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 18 ]
  ! -               [ shift and go to state 19 ]


state 31

    (7) expression -> expression - expression .
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    +               reduce using rule 7 (expression -> expression - expression .)
    -               reduce using rule 7 (expression -> expression - expression .)
    $end            reduce using rule 7 (expression -> expression - expression .)
    )               reduce using rule 7 (expression -> expression - expression .)
    SEMICOLON       reduce using rule 7 (expression -> expression - expression .)
    *               shift and go to state 20
    /               shift and go to state 21

  ! *               [ reduce using rule 7 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 7 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 18 ]
  ! -               [ shift and go to state 19 ]


state 32

    (8) expression -> expression * expression .
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    +               reduce using rule 8 (expression -> expression * expression .)
    -               reduce using rule 8 (expression -> expression * expression .)
    *               reduce using rule 8 (expression -> expression * expression .)
    /               reduce using rule 8 (expression -> expression * expression .)
    $end            reduce using rule 8 (expression -> expression * expression .)
    )               reduce using rule 8 (expression -> expression * expression .)
    SEMICOLON       reduce using rule 8 (expression -> expression * expression .)

  ! +               [ shift and go to state 18 ]
  ! -               [ shift and go to state 19 ]
  ! *               [ shift and go to state 20 ]
  ! /               [ shift and go to state 21 ]


state 33

    (9) expression -> expression / expression .
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    +               reduce using rule 9 (expression -> expression / expression .)
    -               reduce using rule 9 (expression -> expression / expression .)
    *               reduce using rule 9 (expression -> expression / expression .)
    /               reduce using rule 9 (expression -> expression / expression .)
    $end            reduce using rule 9 (expression -> expression / expression .)
    )               reduce using rule 9 (expression -> expression / expression .)
    SEMICOLON       reduce using rule 9 (expression -> expression / expression .)

  ! +               [ shift and go to state 18 ]
  ! -               [ shift and go to state 19 ]
  ! *               [ shift and go to state 20 ]
  ! /               [ shift and go to state 21 ]


state 34

    (15) expression -> DEF ( NAME . , expression )

    ,               shift and go to state 39


state 35

    (17) expression -> ALTER ( NAME . , expression )

    ,               shift and go to state 40


state 36

    (18) expression -> REPEAT LPAREN expression . SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    SEMICOLON       shift and go to state 41
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 37

    (1) statement -> PROC NAME ( expression . )
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    )               shift and go to state 42
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 38

    (16) expression -> NAME ( expression ) .

    +               reduce using rule 16 (expression -> NAME ( expression ) .)
    -               reduce using rule 16 (expression -> NAME ( expression ) .)
    *               reduce using rule 16 (expression -> NAME ( expression ) .)
    /               reduce using rule 16 (expression -> NAME ( expression ) .)
    $end            reduce using rule 16 (expression -> NAME ( expression ) .)
    )               reduce using rule 16 (expression -> NAME ( expression ) .)
    SEMICOLON       reduce using rule 16 (expression -> NAME ( expression ) .)


state 39

    (15) expression -> DEF ( NAME , . expression )
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 43

state 40

    (17) expression -> ALTER ( NAME , . expression )
    (6) expression -> . expression + expression
    (7) expression -> . expression - expression
    (8) expression -> . expression * expression
    (9) expression -> . expression / expression
    (10) expression -> . - expression
    (11) expression -> . ( expression )
    (12) expression -> . INTEGER
    (13) expression -> . BOOL
    (14) expression -> . NAME
    (15) expression -> . DEF ( NAME , expression )
    (16) expression -> . NAME ( expression )
    (17) expression -> . ALTER ( NAME , expression )
    (18) expression -> . REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON

    -               shift and go to state 9
    (               shift and go to state 4
    INTEGER         shift and go to state 10
    BOOL            shift and go to state 11
    NAME            shift and go to state 3
    DEF             shift and go to state 12
    ALTER           shift and go to state 13
    REPEAT          shift and go to state 14

    expression                     shift and go to state 44

state 41

    (18) expression -> REPEAT LPAREN expression SEMICOLON . BREAK SEMICOLON RPAREN SEMICOLON

    BREAK           shift and go to state 45


state 42

    (1) statement -> PROC NAME ( expression ) .

    $end            reduce using rule 1 (statement -> PROC NAME ( expression ) .)


state 43

    (15) expression -> DEF ( NAME , expression . )
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    )               shift and go to state 46
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 44

    (17) expression -> ALTER ( NAME , expression . )
    (6) expression -> expression . + expression
    (7) expression -> expression . - expression
    (8) expression -> expression . * expression
    (9) expression -> expression . / expression

    )               shift and go to state 47
    +               shift and go to state 18
    -               shift and go to state 19
    *               shift and go to state 20
    /               shift and go to state 21


state 45

    (18) expression -> REPEAT LPAREN expression SEMICOLON BREAK . SEMICOLON RPAREN SEMICOLON

    SEMICOLON       shift and go to state 48


state 46

    (15) expression -> DEF ( NAME , expression ) .

    +               reduce using rule 15 (expression -> DEF ( NAME , expression ) .)
    -               reduce using rule 15 (expression -> DEF ( NAME , expression ) .)
    *               reduce using rule 15 (expression -> DEF ( NAME , expression ) .)
    /               reduce using rule 15 (expression -> DEF ( NAME , expression ) .)
    $end            reduce using rule 15 (expression -> DEF ( NAME , expression ) .)
    )               reduce using rule 15 (expression -> DEF ( NAME , expression ) .)
    SEMICOLON       reduce using rule 15 (expression -> DEF ( NAME , expression ) .)


state 47

    (17) expression -> ALTER ( NAME , expression ) .

    +               reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)
    -               reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)
    *               reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)
    /               reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)
    $end            reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)
    )               reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)
    SEMICOLON       reduce using rule 17 (expression -> ALTER ( NAME , expression ) .)


state 48

    (18) expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON . RPAREN SEMICOLON

    RPAREN          shift and go to state 49


state 49

    (18) expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 50


state 50

    (18) expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .

    +               reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)
    -               reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)
    *               reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)
    /               reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)
    $end            reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)
    )               reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 18 (expression -> REPEAT LPAREN expression SEMICOLON BREAK SEMICOLON RPAREN SEMICOLON .)

